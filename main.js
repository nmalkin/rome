// Generated by CoffeeScript 1.6.2
(function() {
  var DATA, LAYERS, MAIN, OFFSCREEN, ROUNDS, START_BOUNDS, TILE_LAYER_MAP, TILE_LAYER_SAT, TILE_SETTINGS, dist2, distToSegment, distToSegmentSquared, distanceToPolygon, game, loadLocationDescription, placeTemplate, pointInsidePolygon, resize, round2, roundNumber, sqr, warnAboutExit, _gameLayer, _map,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ROUNDS = 3;

  MAIN = '#sidebar';

  OFFSCREEN = [0, 0];

  TILE_SETTINGS = {
    attribution: "Map data © <a href=\"http://www.openstreetmap.org/\" target=\"_blank\">OpenStreetMap</a> contributors — Tiles courtesy of <a href=\"http://www.mapquest.com/\" target=\"_blank\">MapQuest</a>",
    subdomains: ["otile1", "otile2", "otile3", "otile4"]
  };

  TILE_LAYER_MAP = new L.TileLayer("http://{s}.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.jpg", TILE_SETTINGS);

  TILE_LAYER_SAT = new L.TileLayer("http://{s}.mqcdn.com/tiles/1.0.0/sat/{z}/{x}/{y}.jpg", TILE_SETTINGS);

  LAYERS = [TILE_LAYER_MAP, TILE_LAYER_SAT];

  START_BOUNDS = [[41.886751707869635, 12.471263408660887], [41.89435512030309, 12.495853900909424]];

  resize = function() {
    var map, viewHeight;

    viewHeight = $(window).height() - 40;
    map = $("#map");
    map.width(map.parent().width()).height(viewHeight);
    return $("#sidebar").height(viewHeight);
  };

  resize();

  $(window).resize(resize);

  _map = new L.Map('map', {
    doubleClickZoom: false
  });

  _map.addLayer(TILE_LAYER_MAP);

  _map.fitBounds(START_BOUNDS);

  DATA = (function() {
    var data, feature, features, metadata, name, property, _i, _len;

    data = [];
    if (GEODATA.type !== 'FeatureCollection') {
      alert('Unexpected geodata. Things are about to break.');
    }
    features = GEODATA.features;
    for (_i = 0, _len = features.length; _i < _len; _i++) {
      feature = features[_i];
      name = feature.properties.Name;
      if (name in METADATA) {
        metadata = METADATA[name];
        for (property in metadata) {
          feature.properties[property] = metadata[property];
        }
      }
      data.push(feature);
    }
    return data;
  })();

  placeTemplate = Handlebars.compile($('#template-place').html());

  loadLocationDescription = function(location) {
    var html;

    html = placeTemplate(location.properties);
    return $(MAIN).html(html);
  };

  warnAboutExit = function() {
    return confirm("Your game state will be lost if your reload the page. Continue?");
  };

  _gameLayer = L.layerGroup().addTo(_map);

  game = {
    start: function() {
      var html, points, returning, template;

      points = localStorage.getItem('best');
      returning = points !== null;
      template = Handlebars.compile($('#template-welcome').html());
      html = template({
        returning: returning,
        points: round2(points)
      });
      $(MAIN).html(html);
      return $('#begin').click(function() {
        $('#map').css('opacity', 1);
        return game.play();
      });
    },
    play: function() {
      var allowInfoScreen, currentLocation, drawGroundTruth, finalizeGuess, getDistance, guessMarker, guessMarkerContent, lastLandmark, nextLocation, playNextRound, processGeoFeature, registerGuess, resultsTemplate, round, showResults, totalPoints, usedLocations;

      round = 0;
      totalPoints = 0;
      usedLocations = [];
      currentLocation = null;
      lastLandmark = null;
      allowInfoScreen = false;
      playNextRound = function() {
        round++;
        currentLocation = nextLocation();
        loadLocationDescription(currentLocation);
        _map.on('dblclick', registerGuess);
        return _map.addLayer(guessMarker);
      };
      nextLocation = function() {
        var choice, nextChoice;

        nextChoice = function() {
          return Math.floor(Math.random() * DATA.length);
        };
        choice = nextChoice();
        while ((__indexOf.call(usedLocations, choice) >= 0) || (DATA[choice]['geometry']['type'] !== 'Polygon')) {
          choice = nextChoice();
        }
        usedLocations.push(choice);
        return DATA[choice];
      };
      registerGuess = function(e) {
        guessMarker.setLatLng(e.latlng);
        return guessMarker.openPopup();
      };
      finalizeGuess = function() {
        var guess, permanentGuessMarker;

        _map.off('dblclick', registerGuess);
        guess = guessMarker.getLatLng();
        _map.removeLayer(guessMarker);
        permanentGuessMarker = new L.Marker(guess, {
          draggable: false
        });
        permanentGuessMarker.bindPopup("Your guess for the location of the " + currentLocation.properties.Name);
        _gameLayer.addLayer(permanentGuessMarker);
        return showResults(guess);
      };
      resultsTemplate = Handlebars.compile($('#template-results').html());
      showResults = function(guess) {
        var close, connector, distance, exact, html, meters, points, showResultsScreen, truthCenter;

        drawGroundTruth(currentLocation);
        truthCenter = lastLandmark.getBounds().getCenter();
        connector = L.polyline([guess, truthCenter], {
          color: 'red'
        });
        connector.addTo(_gameLayer);
        distance = getDistance(guess, currentLocation);
        if (isNaN(distance)) {
          console.log(guess, currentLocation, distance);
          alert('Internal error (distance NaN)');
          return;
        }
        meters = guess.distanceTo(new L.LatLng(guess.lat + distance, guess.lng));
        exact = distance === 0;
        close = meters < 50;
        points = meters;
        totalPoints += meters;
        html = resultsTemplate({
          exact: exact,
          close: close,
          distance: Math.round(meters),
          points: round2(points),
          total: round2(totalPoints),
          place: currentLocation.properties.Name,
          last: round === ROUNDS
        });
        showResultsScreen = function() {
          $(MAIN).html(html);
          return $('#continue').on('click', function() {
            _map.off('click', showResultsScreen);
            _gameLayer.removeLayer(connector);
            if (round >= ROUNDS) {
              return game.finish(totalPoints);
            } else {
              allowInfoScreen = false;
              return playNextRound();
            }
          });
        };
        allowInfoScreen = true;
        _map.on('click', showResultsScreen);
        return showResultsScreen();
      };
      drawGroundTruth = function(location) {
        lastLandmark = L.geoJson(location, {
          onEachFeature: processGeoFeature
        });
        (function(currentLocation) {
          return lastLandmark.on('click', function() {
            if (allowInfoScreen) {
              return loadLocationDescription(currentLocation);
            }
          });
        })(currentLocation);
        return _gameLayer.addLayer(lastLandmark);
      };
      processGeoFeature = function(feature, layer) {
        var name, type;

        type = feature.geometry.type;
        if (type === "Polygon") {
          name = feature.properties.Name;
          return layer.bindPopup(name);
        }
      };
      getDistance = function(guess, truth) {
        var inside, point, polygon;

        point = [guess.lng, guess.lat];
        polygon = truth.geometry.coordinates[0];
        inside = pointInsidePolygon(point, polygon);
        if (inside) {
          return 0;
        } else {
          return distanceToPolygon(point, polygon);
        }
      };
      guessMarker = new L.Marker(OFFSCREEN, {
        draggable: true,
        title: 'Your guess for the location'
      });
      guessMarkerContent = $('<input type="button" id="final" class="btn btn-primary" value="Yes, this is my final answer" />');
      guessMarkerContent.click(finalizeGuess);
      guessMarker.bindPopup(guessMarkerContent[0]);
      playNextRound();
      return $('.navbar .brand').on('click', warnAboutExit);
    },
    finish: function(score) {
      var best, finishTemplate, html, message, restartGame, returning, showEndScreen;

      best = localStorage.getItem('best');
      returning = best !== null;
      message = score === 0 ? 'Genius!' : score < 10 ? 'Amazing!' : score < 25 ? 'Excellent!' : score < 50 ? 'Great job!' : score < 75 ? 'Good job!' : score < 100 ? 'Nicely done!' : 'Results';
      finishTemplate = Handlebars.compile($('#template-finish').html());
      html = finishTemplate({
        total: roundNumber(score, 2),
        returning: returning,
        previous: roundNumber(best, 2),
        improved: score < best,
        acknowledgment: message
      });
      showEndScreen = function() {
        $(MAIN).html(html);
        return $('#repeat').click(restartGame);
      };
      restartGame = function() {
        _map.off('click', showEndScreen);
        _gameLayer.clearLayers();
        return game.play();
      };
      _map.on('click', showEndScreen);
      showEndScreen();
      if (returning) {
        best = Math.min(best, score);
      } else {
        best = score;
      }
      localStorage.setItem('best', best);
      return $('.navbar .brand').off('click', warnAboutExit);
    }
  };

  pointInsidePolygon = function(point, vs) {
    var i, inside, intersect, j, x, xi, xj, y, yi, yj;

    x = point[0];
    y = point[1];
    inside = false;
    i = 0;
    j = vs.length - 1;
    while (i < vs.length) {
      xi = vs[i][0];
      yi = vs[i][1];
      xj = vs[j][0];
      yj = vs[j][1];
      intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) {
        inside = !inside;
      }
      j = i++;
    }
    return inside;
  };

  sqr = function(x) {
    return x * x;
  };

  dist2 = function(v, w) {
    return sqr(v[0] - w[0]) + sqr(v[1] - w[1]);
  };

  distToSegmentSquared = function(p, v, w) {
    var l2, t;

    l2 = dist2(v, w);
    if (l2 === 0) {
      return dist2(p, v);
    }
    t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;
    if (t < 0) {
      return dist2(p, v);
    }
    if (t > 1) {
      return dist2(p, w);
    }
    return dist2(p, {
      x: v[0] + t * (w[0] - v[0]),
      y: v[1] + t * (w[1] - v[1])
    });
  };

  distToSegment = function(p, v, w) {
    return Math.sqrt(distToSegmentSquared(p, v, w));
  };

  distanceToPolygon = function(point, polygon) {
    var minimumDistance, myMin, v, _i, _ref;

    myMin = function(a, b) {
      if (isNaN(a)) {
        return b;
      } else if (isNaN(b)) {
        return a;
      } else {
        return Math.min(a, b);
      }
    };
    minimumDistance = Infinity;
    minimumDistance = myMin(minimumDistance, distToSegment(point, polygon[0], polygon[polygon.length - 1]));
    for (v = _i = 1, _ref = polygon.length; 1 <= _ref ? _i < _ref : _i > _ref; v = 1 <= _ref ? ++_i : --_i) {
      minimumDistance = myMin(minimumDistance, distToSegment(point, polygon[v - 1], polygon[v]));
    }
    return minimumDistance;
  };

  roundNumber = function(num, dec) {
    return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
  };

  round2 = function(num) {
    return roundNumber(num, 2);
  };

  game.start();

}).call(this);
